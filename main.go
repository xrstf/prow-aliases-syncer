package main

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"go.xrstf.de/prow-aliases-syncer/pkg/git"
	"go.xrstf.de/prow-aliases-syncer/pkg/github"
	"go.xrstf.de/prow-aliases-syncer/pkg/prow"
	"go.xrstf.de/prow-aliases-syncer/pkg/util"

	"github.com/sirupsen/logrus"
	"github.com/spf13/pflag"
)

type options struct {
	organization       string
	targetOrganization string
	branches           []string
	ignoredUsers       []string
	bodyFile           string
	body               *template.Template
	headerFile         string
	header             string
	maxAge             time.Duration
	dryRun             bool
	updateDirectly     bool
	strict             bool
	keep               bool
	verbose            bool
}

const defaultFileHeader = `
# This file was automatically generated by prow-aliases-syncer. DO NOT EDIT.
`

const defaultPRBody = `
This pull request updates the {{ .Filename }} file based on the GitHub team associations.

**Release Notes:**
§§§release-note
NONE
§§§
`

// number of commits to retrieve per branch to check for the most recent commit
const peekDepth = 20

type templateData struct {
	Filename   string
	BaseBranch string
	HeadBranch string
	Org        string
	Repo       string
}

func main() {
	body := strings.ReplaceAll(defaultPRBody, "§", "`")

	opt := options{
		maxAge: 90 * 24 * time.Hour,
		header: defaultFileHeader,
	}

	pflag.StringVarP(&opt.organization, "org", "o", opt.organization, "GitHub organization to load teams from and update repositories in (unless --target-org is given)")
	pflag.StringVarP(&opt.targetOrganization, "target-org", "t", opt.targetOrganization, "update repositories in this org based on the teams from --org")
	pflag.StringVar(&opt.bodyFile, "body", opt.bodyFile, "file with a template for the PR body")
	pflag.StringVar(&opt.headerFile, "header", opt.headerFile, "file with header for the generated aliases files")
	pflag.StringSliceVarP(&opt.branches, "branch", "b", opt.branches, "branch to update (glob expression supported) (can be given multiple times)")
	pflag.StringSliceVarP(&opt.ignoredUsers, "ignore-user", "i", opt.ignoredUsers, "GitHub usernames which should be ignored when determining the most recent commit on branch (can be given multiple times)")
	pflag.BoolVar(&opt.dryRun, "dry-run", opt.dryRun, "do not actually push to GitHub (repositories will still be cloned and locally updated)")
	pflag.BoolVarP(&opt.strict, "strict", "s", opt.strict, "compare owners files byte by byte")
	pflag.BoolVarP(&opt.updateDirectly, "update", "u", opt.updateDirectly, "do not create pull requests, but directly push into the target branches")
	pflag.BoolVarP(&opt.keep, "keep", "k", opt.keep, "keep unknown teams (do not combine with -strict)")
	pflag.BoolVarP(&opt.verbose, "verbose", "v", opt.verbose, "Enable more verbose output")
	pflag.DurationVar(&opt.maxAge, "max-age", opt.maxAge, "only update branches with commits within this duration")
	pflag.Parse()

	// setup logging
	var log = logrus.New()
	log.SetFormatter(&logrus.TextFormatter{
		FullTimestamp:   true,
		TimestampFormat: time.RFC1123,
	})

	if opt.verbose {
		log.SetLevel(logrus.DebugLevel)
	}

	// validate CLI flags
	if opt.organization == "" {
		log.Fatal("No -org given.")
	}

	if len(opt.branches) == 0 {
		log.Fatal("No -branch given.")
	}

	token := os.Getenv("GITHUB_TOKEN")
	if len(token) == 0 {
		log.Fatal("No GITHUB_TOKEN environment variable defined.")
	}

	if len(opt.headerFile) > 0 {
		content, err := os.ReadFile(opt.headerFile)
		if err != nil {
			log.Fatalf("Failed to read --header file: %v", err)
		}

		opt.header = string(content)
	}

	if len(opt.bodyFile) > 0 {
		content, err := os.ReadFile(opt.bodyFile)
		if err != nil {
			log.Fatalf("Failed to read --body file: %v", err)
		}

		body = string(content)
	}

	tpl, err := template.New("body").Parse(body)
	if err != nil {
		log.Fatalf("--body template is not a valid template: %v", err)
	}
	opt.body = tpl

	logger := log.WithField("org", opt.organization)
	if opt.targetOrganization != "" {
		logger = logger.WithField("target", opt.targetOrganization)
	} else {
		opt.targetOrganization = opt.organization
	}

	// setup API client
	ctx := context.Background()

	client, err := github.NewClient(ctx, logger, token)
	if err != nil {
		logger.Fatalf("Failed to create API client: %v", err)
	}

	if err := work(ctx, client, logger, opt); err != nil {
		logger.Fatalf("Failure: %v", err)
	}

	logger.Info("Synchronization completed.")
}

func work(ctx context.Context, client *github.Client, log logrus.FieldLogger, opt options) error {
	// list all teams and their members
	log.Info("Listing teams…")

	teams, err := client.GetTeams(opt.organization)
	if err != nil {
		return err
	}

	log.Infof("Found %d teams.", len(teams))

	for _, team := range teams {
		log.WithField("team", team.Slug).WithField("members", team.Members).Debug("Found team.")
	}

	// list all repos with all branches and the OWNERS_ALIASES file in each of them
	log.Info("Listing repositories and branches…")

	repos, err := client.GetRepositoriesAndBranches(opt.targetOrganization, opt.ignoredUsers, peekDepth)
	if err != nil {
		return err
	}

	log.Infof("Found %d repositories.", len(repos))

	todo, err := createJobs(ctx, log, opt, repos, teams)
	if err != nil {
		return fmt.Errorf("failed to determine tasks: %w", err)
	}

	if len(todo) == 0 {
		return nil
	}

	if err := processTasks(ctx, client, log, opt, todo); err != nil {
		return fmt.Errorf("failed to process: %w", err)
	}

	return nil
}

func createJobs(ctx context.Context, log logrus.FieldLogger, opt options, repos []github.Repository, teams []github.Team) ([]github.Repository, error) {
	todo := []github.Repository{}

	for _, r := range repos {
		rlog := log.WithField("repo", r.Name)
		branchesToUpdate := []github.Branch{}

		for _, b := range r.Branches {
			blog := rlog.WithField("branch", b.Name)

			// apply branch filter
			if !includeBranch(b.Name, opt.branches) {
				blog.Debug("Ignored.")
				continue
			}

			// ignore stale branches
			if time.Since(b.MostRecentCommit) > opt.maxAge {
				blog.Debug("No recent activity, ignored.")
				continue
			}

			// if the branch has no alias file, ignore it
			if b.Aliases == "" {
				blog.Debug("Has no aliases file.")
				continue
			}

			equal, newAliases, err := util.Equal(b.Aliases, teams, opt.strict, opt.keep, opt.header)
			if err != nil {
				blog.WithError(err).Warn("Invalid aliases file.")
				continue
			}

			if !equal {
				blog.Info("File is not identical.")

				// store the new data so we do not have to generate it again later
				b.Aliases = newAliases

				branchesToUpdate = append(branchesToUpdate, b)
			} else {
				blog.Debug("No changes detected.")
			}
		}

		if len(branchesToUpdate) > 0 {
			todo = append(todo, github.Repository{
				ID:       r.ID,
				Name:     r.Name,
				Branches: branchesToUpdate,
			})
		}
	}

	return todo, nil
}

func processTasks(ctx context.Context, client *github.Client, log logrus.FieldLogger, opt options, tasks []github.Repository) error {
	tmpDir, err := os.MkdirTemp("", "xrstf*")
	if err != nil {
		return fmt.Errorf("failed to create temporary directory: %w", err)
	}

	gitter := git.NewClient(log, opt.verbose)

	for _, task := range tasks {
		tlog := log.WithField("repo", task.Name)
		tlog.Info("Processing…")

		cloned := false

		repoURL := fmt.Sprintf("git@github.com:%s/%s.git", opt.targetOrganization, task.Name)
		repoDir := filepath.Join(tmpDir, task.Name)

		for _, branch := range task.Branches {
			blog := tlog.WithField("branch", branch.Name)
			newBranch := fmt.Sprintf("update-%s-owners", branch.Name)
			newBranch = strings.ReplaceAll(newBranch, "/", "-")

			if !opt.updateDirectly {
				prNumber, err := client.GetPullRequestForBranch(opt.targetOrganization, task.Name, branch.Name, newBranch)
				if err != nil {
					blog.WithError(err).Warn("Failed to check for existing pull request.")
					continue
				}

				if prNumber > 0 {
					blog.WithField("pr", prNumber).Info("Pull request already open.")
					continue
				}

			}

			if !cloned {
				tlog.Debug("Cloning…")
				if err := gitter.CloneRepository(repoURL, repoDir); err != nil {
					tlog.WithError(err).Warn("Failed to clone repository.")
					continue
				}

				cloned = true
			}

			// just for safety
			if err := gitter.ResetRepository(repoDir); err != nil {
				blog.WithError(err).Warn("Failed to reset working copy.")
				continue
			}

			if err := gitter.CheckoutBranch(repoDir, branch.Name); err != nil {
				blog.WithError(err).Warn("Failed to checkout branch.")
				continue
			}

			if !opt.updateDirectly {
				if err := gitter.CreateBranch(repoDir, newBranch); err != nil {
					blog.WithError(err).Warn("Failed to create new branch.")
					continue
				}
			}

			filename := filepath.Join(repoDir, prow.OwnersAliasesFilename)
			if err := os.WriteFile(filename, []byte(branch.Aliases), 0644); err != nil {
				blog.WithError(err).Warn("Failed to update file.")
				continue
			}

			commitMsg := fmt.Sprintf("Synchronize %s file with Github teams", prow.OwnersAliasesFilename)
			if branch.Name != "master" && branch.Name != "main" {
				commitMsg = fmt.Sprintf("[%s] %s", branch.Name, commitMsg)
			}

			if err := gitter.Commit(repoDir, commitMsg); err != nil {
				blog.WithError(err).Warn("Failed to commit changes.")
				continue
			}

			if opt.dryRun {
				if !opt.updateDirectly {
					blog = blog.WithField("new-branch", newBranch)
				}

				blog.Info("Dry run, not pushing branch.")
				continue
			}

			if err := gitter.Push(repoDir, "origin", newBranch); err != nil {
				blog.WithError(err).Warn("Failed to push changes.")
				continue
			}

			if opt.updateDirectly {
				blog.Info("Branch updated.")
			} else {
				data := templateData{
					Filename:   prow.OwnersAliasesFilename,
					BaseBranch: branch.Name,
					HeadBranch: newBranch,
					Org:        opt.targetOrganization,
					Repo:       task.Name,
				}

				var buf bytes.Buffer
				if err := opt.body.Execute(&buf, data); err != nil {
					blog.WithError(err).Error("Failed to render body template.")
					continue
				}

				body := strings.TrimSpace(buf.String())

				prNumber, err := client.CreatePullRequest(task.ID, branch.Name, newBranch, commitMsg, body)
				if err != nil {
					blog.WithError(err).Warn("Failed to create pull request.")
					continue
				}

				blog.WithField("pr", prNumber).Info("Pull request created.")
			}
		}
	}

	return nil
}

func includeBranch(branch string, enabled []string) bool {
	for _, b := range enabled {
		if matched, _ := filepath.Match(b, branch); matched {
			return true
		}
	}

	return false
}
